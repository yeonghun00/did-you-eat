rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Users collection - users can only access their own data
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // Families collection - enhanced security with backward compatibility
    match /families/{familyId} {
      // Helper function to check if user has access to this family (for registered users)
      function hasAccessToFamily() {
        return request.auth != null && 
               exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
               get(/databases/$(database)/documents/users/$(request.auth.uid)).data.familyCodes != null &&
               resource.data.connectionCode in get(/databases/$(database)/documents/users/$(request.auth.uid)).data.familyCodes;
      }
      
      // Helper function to check if user is in memberIds (for existing members)
      // Handles both new and legacy family documents
      function isInMemberIds() {
        return request.auth != null && 
               (
                 // New families with memberIds field
                 ('memberIds' in resource.data && request.auth.uid in resource.data.memberIds) ||
                 // Legacy families without memberIds - allow access for migration
                 (!('memberIds' in resource.data) || resource.data.memberIds == null)
               );
      }
      
      // Helper function to check if this is a legacy family (missing memberIds)
      // Handles multiple scenarios: field missing, null, undefined, or empty list
      function isLegacyFamily() {
        return !('memberIds' in resource.data) || 
               resource.data.memberIds == null || 
               resource.data.get('memberIds', null) == null ||
               (resource.data.memberIds is list && resource.data.memberIds.size() == 0);
      }
      
      // Helper function for child app connection code lookup
      // Allows reading any family for connection code validation and legacy family access
      function isConnectionCodeLookup() {
        return request.auth != null;
      }
      
      // Helper function to check if this is a legacy family access during connection process
      // Allows authenticated users to access legacy families for migration
      function isLegacyFamilyAccess() {
        return request.auth != null && isLegacyFamily();
      }
      
      // Helper function to check if this is a child app joining operation
      // Handles both new families and legacy family migration
      function isChildAppJoining() {
        return request.auth != null &&
               (
                 // New families: User is being added to memberIds (not already present)
                 ('memberIds' in resource.data && 
                  resource.data.memberIds is list &&
                  resource.data.memberIds.size() > 0 &&
                  request.auth.uid in request.resource.data.get('memberIds', []) &&
                  !(request.auth.uid in resource.data.get('memberIds', []))) ||
                 
                 // Legacy families: Adding memberIds field for the first time during migration
                 (isLegacyFamily() && 
                  'memberIds' in request.resource.data &&
                  request.resource.data.memberIds is list &&
                  request.auth.uid in request.resource.data.get('memberIds', []))
               ) &&
               // Only allow approval-related fields to be updated during joining
               request.resource.data.diff(resource.data).affectedKeys()
               .hasOnly(['approved', 'approvedAt', 'approvedBy', 'memberIds', 'childInfo']);
      }
      
      // Helper function to check if this is a standard approval operation
      // Handles both new and legacy families
      function isApprovalOperation() {
        return request.auth != null &&
               request.resource.data.diff(resource.data).affectedKeys()
               .hasOnly(['approved', 'approvedAt', 'approvedBy', 'childAppUserId', 'memberIds', 'childInfo']);
      }
      
      // Helper function for legacy family migration
      // Allows authenticated users to migrate legacy families by adding memberIds
      function isLegacyMigration() {
        return request.auth != null &&
               isLegacyFamily() &&
               // Allow adding memberIds field during migration
               'memberIds' in request.resource.data &&
               request.resource.data.memberIds is list &&
               request.resource.data.memberIds.size() > 0 &&
               // Ensure only migration-related fields are being updated
               request.resource.data.diff(resource.data).affectedKeys()
               .hasOnly(['approved', 'approvedAt', 'approvedBy', 'memberIds', 'childInfo']);
      }
      
      // Helper function specifically for legacy family initial access
      // Allows any authenticated user to read legacy families for connection purposes
      function canAccessLegacyFamily() {
        return request.auth != null && isLegacyFamily();
      }
      
      // Read access: Allow authenticated users to read families
      // This is essential for connection code lookup, validation, and legacy family access
      // 'allow read' covers both get() and list() operations (queries)
      // Simplified to just check authentication for connection code lookup
      allow read: if request.auth != null;
      
      // Write access: multiple scenarios with backward compatibility
      allow update: if (
        // Scenario 1: Child app approval - SIMPLIFIED to avoid circular permission checks
        // Allow any authenticated user to update approval fields and add themselves to memberIds
        (request.auth != null &&
         request.resource.data.diff(resource.data).affectedKeys()
         .hasOnly(['approved', 'approvedAt', 'approvedBy', 'memberIds', 'childInfo', 'childAppUserId']) &&
         request.auth.uid in request.resource.data.get('memberIds', [])) ||

        // Scenario 2: Registered users with proper family access
        (hasAccessToFamily() &&
         request.resource.data.diff(resource.data).affectedKeys()
         .hasOnly(['survivalAlert', 'settings', 'lastChildAppActivity'])) ||

        // Scenario 3: Existing family members (handles legacy families)
        // Allow updates for all operational fields (GPS, survival, meals, alerts, etc.)
        (isInMemberIds() &&
         request.resource.data.diff(resource.data).affectedKeys()
         .hasOnly([
           'survivalAlert', 'settings', 'lastChildAppActivity',
           'alerts', 'alertsCleared', 'alertsClearedBy', 'alertsTriggered',
           'location', 'lastLocationUpdate',
           'lastPhoneActivity', 'blastPhoneActivity', 'lastActive',
           'lastMeal', 'lastMealTime', 'todayMealCount'
         ])) ||

        // Scenario 4: Allow authenticated users to update core activity fields
        // This handles parent app updates when not yet in memberIds
        (request.auth != null &&
         request.resource.data.diff(resource.data).affectedKeys()
         .hasOnly([
           'location', 'lastLocationUpdate',
           'lastPhoneActivity', 'blastPhoneActivity', 'lastActive',
           'lastMeal', 'lastMealTime', 'todayMealCount',
           'alerts', 'alertsTriggered'
         ]))
      );
      
      // Create/Delete: only authenticated users
      allow create: if request.auth != null;
      allow delete: if request.auth != null && (hasAccessToFamily() || isInMemberIds());
      
      // Recordings subcollection - allow authenticated users
      match /recordings/{document=**} {
        allow read, write: if request.auth != null;
      }

      // Meals subcollection - allow authenticated users
      match /meals/{document=**} {
        allow read, write: if request.auth != null;
      }
      
      // Child devices subcollection - for FCM token registration
      match /child_devices/{deviceId} {
        allow read, write: if request.auth != null;
      }
    }
    
    // Connection codes collection - for secure family joining
    match /connection_codes/{codeId} {
      // Allow authenticated users to read connection codes for family lookup
      allow read: if request.auth != null;

      // Only allow creating/updating connection codes by authenticated users
      // (typically parent app creating codes)
      allow create, update: if request.auth != null;

      // Allow deletion by authenticated users (cleanup)
      allow delete: if request.auth != null;
    }

    // Subscriptions collection - for in-app purchases and subscription management
    match /subscriptions/{userId} {
      // Users can read/write their own subscription data
      allow read, write: if request.auth != null && request.auth.uid == userId;

      // Events subcollection for subscription events
      match /events/{eventId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }
    
    // FCM tokens collection for notifications
    match /fcmTokens/{tokenId} {
      allow read, write: if request.auth != null;
    }
    
    // App analytics and logs (if needed)
    match /analytics/{document=**} {
      allow read, write: if request.auth != null;
    }
    
    // Global app settings (read-only for users)
    match /appSettings/{document=**} {
      allow read: if request.auth != null;
      allow write: if false; // Only admin can write
    }

    // Test collection for development/debugging
    match /_test/{document=**} {
      allow read, write: if request.auth != null;
    }
  }
}